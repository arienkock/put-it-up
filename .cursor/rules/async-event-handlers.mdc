---
alwaysApply: true
---

# Async Code and Event Handler Development Rules

## Core Principles

When writing any async code or event handler code, follow these mandatory patterns derived from successful refactoring of connector-events, sticky-events, keyboard-handlers, and the comprehensive State Machine Prevention Plan implementation:

### 1. State Machine Base Class Architecture (MANDATORY)

**NEVER use scattered boolean flags or implicit state.** Always extend the StateMachine base class:

```javascript
// ✅ CORRECT: Extend StateMachine base class
import { StateMachine, createStateConfig } from '../ui/state-machine-base.js';

const ComponentState = {
  IDLE: 'idle',
  PROCESSING: 'processing',
  WAITING: 'waiting',
  ERROR: 'error'
};

class ComponentStateMachine extends StateMachine {
  constructor(dependencies) {
    const stateConfig = createStateConfig(ComponentState);
    
    // Configure each state with explicit setup, cleanup, and validation
    stateConfig[ComponentState.IDLE] = {
      setup: (stateData, stateMachine) => {
        stateMachine.clearAllListeners();
        stateMachine.resetState();
      },
      cleanup: (stateData, stateMachine) => {
        stateMachine.clearAllListeners();
      },
      validate: (stateData, stateMachine) => {
        return stateMachine.isIdle === true;
      }
    };
    
    super(ComponentState.IDLE, stateConfig);
    
    // Initialize properties after super constructor
    this.dependencies = dependencies;
    this.globalListeners = new GlobalListenerManager();
  }
}

// ❌ WRONG: Scattered boolean flags or manual state management
let isProcessing = false;
let isWaiting = false;
let hasError = false;
let currentId = null;
```

### 2. Constructor Initialization Pattern (MANDATORY)

**NEVER access `this` before calling `super()`.** Always initialize properties after the super constructor:

```javascript
// ✅ CORRECT: Proper constructor initialization
class ComponentStateMachine extends StateMachine {
  constructor(dependencies) {
    const stateConfig = createStateConfig(ComponentState);
    
    // Configure state config BEFORE super()
    stateConfig[ComponentState.IDLE] = {
      setup: (stateData, stateMachine) => {
        // Use stateMachine parameter, not 'this'
        if (stateMachine.globalListeners) {
          stateMachine.clearAllListeners();
        }
      }
    };
    
    super(ComponentState.IDLE, stateConfig);
    
    // Initialize properties AFTER super constructor
    this.dependencies = dependencies;
    this.globalListeners = new GlobalListenerManager();
    
    // Re-initialize initial state now that properties are set
    this.initializeState(ComponentState.IDLE);
  }
}

// ❌ WRONG: Accessing 'this' before super() or in state setup
class ComponentStateMachine extends StateMachine {
  constructor(dependencies) {
    this.dependencies = dependencies; // ❌ Before super()
    
    const stateConfig = createStateConfig(ComponentState);
    stateConfig[ComponentState.IDLE] = {
      setup: (stateData, stateMachine) => {
        this.clearAllListeners(); // ❌ Using 'this' in setup
      }
    };
    
    super(ComponentState.IDLE, stateConfig);
  }
}
```

### 3. Single Entry Point with Routing (MANDATORY)

**NEVER add multiple independent event listeners for the same event type.** Use one router that delegates to sub-handlers:

```javascript
// ✅ CORRECT: Single entry point with routing
element.addEventListener('eventType', (event) => {
  const appState = store.getAppState();
  
  // Route to appropriate handler based on current state
  for (const handlerName of HANDLER_PRIORITY) {
    const handler = handlers[handlerName];
    if (handler.canHandle && handler.canHandle(event, currentState, appState)) {
      if (handler.onEvent) {
        return handleEvent('eventType', event, handler.onEvent);
      }
    }
  }
});

// ❌ WRONG: Multiple independent listeners
element.addEventListener('eventType', handler1);
element.addEventListener('eventType', handler2);
element.addEventListener('eventType', handler3);
```

### 4. Sub-Handler Architecture with Explicit Precedence (MANDATORY)

**NEVER put all logic in one monolithic handler.** Break into focused sub-handlers with clear precedence:

```javascript
// ✅ CORRECT: Sub-handlers with explicit precedence
const handlers = {
  highPriorityHandler: {
    canHandle: (event, state, appState) => {
      return state === ComponentState.IDLE && event.key === 'Escape';
    },
    
    onEvent: (event, stateData) => {
      // Handle high priority action
      transitionState(ComponentState.PROCESSING, 'high priority action');
    }
  },
  
  normalHandler: {
    canHandle: (event, state, appState) => {
      return state === ComponentState.IDLE && event.key === 'Enter';
    },
    
    onEvent: (event, stateData) => {
      // Handle normal action
      transitionState(ComponentState.PROCESSING, 'normal action');
    }
  }
};

// Explicit priority order
const HANDLER_PRIORITY = [
  'highPriorityHandler',
  'normalHandler'
];

// ❌ WRONG: Monolithic handler
function handleEvent(event) {
  if (event.key === 'Escape') {
    // handle escape
  } else if (event.key === 'Enter') {
    // handle enter
  } else if (event.key === 'Space') {
    // handle space
  }
  // ... 200 more lines
}
```

### 5. Centralized Event Listener Management (MANDATORY)

**NEVER manually add/remove global listeners without proper management.** Use a listener manager:

```javascript
// ✅ CORRECT: Listener manager
class EventListenerManager {
  constructor() {
    this.activeListeners = new Map(); // type -> Set of handlers
  }
  
  setListeners(listenerMap) {
    this.clearAll();
    
    Object.entries(listenerMap).forEach(([eventType, handler]) => {
      document.addEventListener(eventType, handler);
      
      if (!this.activeListeners.has(eventType)) {
        this.activeListeners.set(eventType, new Set());
      }
      this.activeListeners.get(eventType).add(handler);
    });
  }
  
  clearAll() {
    this.activeListeners.forEach((handlers, eventType) => {
      handlers.forEach(handler => {
        document.removeEventListener(eventType, handler);
      });
    });
    this.activeListeners.clear();
  }
}

const listenerManager = new EventListenerManager();

// ❌ WRONG: Manual listener management
document.addEventListener('mousemove', handler1);
document.addEventListener('mouseup', handler2);
// ... later, easy to forget to remove them
```

### 6. Explicit State Transitions with Logging (MANDATORY)

**NEVER change state implicitly.** Always use explicit transition functions with logging:

```javascript
// ✅ CORRECT: Explicit state transitions
const DEBUG_MODE = true;

function transitionState(newState, reason, data = {}) {
  const oldState = currentState;
  
  if (DEBUG_MODE) {
    console.log(`[ComponentState] ${oldState} → ${newState}`, {
      reason,
      data,
      timestamp: Date.now()
    });
  }
  
  // Clean up old state
  switch (oldState) {
    case ComponentState.PROCESSING:
      listenerManager.clearAll();
      break;
  }
  
  currentState = newState;
  
  // Set up new state
  switch (newState) {
    case ComponentState.IDLE:
      stateData = {};
      break;
    case ComponentState.PROCESSING:
      listenerManager.setListeners({
        'mousemove': handleMove,
        'mouseup': handleEnd
      });
      break;
  }
}

// ❌ WRONG: Implicit state changes
currentState = ComponentState.PROCESSING;
isProcessing = true;
// No cleanup, no logging, no setup
```

### 7. Event Handling Wrapper with Error Recovery (MANDATORY)

**NEVER call handlers directly.** Always wrap in error handling:

```javascript
// ✅ CORRECT: Event wrapper with error recovery
function handleEvent(eventName, event, handlerFn) {
  if (DEBUG_MODE) {
    console.log(`[ComponentEvent] ${eventName} in ${currentState}`, {
      target: event.target?.className || 'unknown',
      handler: handlerFn.name,
      stateData: { ...stateData }
    });
  }
  
  try {
    return handlerFn(event, stateData);
  } catch (error) {
    console.error(`[ComponentError] in ${handlerFn.name}:`, error);
    // Reset to safe state
    transitionState(ComponentState.IDLE, 'error recovery');
    throw error;
  }
}

// ❌ WRONG: Direct handler calls
handlerFn(event); // No error handling, no logging
```

### 8. Async Operation Patterns (MANDATORY)

**NEVER use async/await without proper state management.** Always track async operations:

```javascript
// ✅ CORRECT: Async with state management
async function performAsyncOperation(data) {
  transitionState(ComponentState.PROCESSING, 'async operation started');
  
  try {
    const result = await someAsyncCall(data);
    transitionState(ComponentState.IDLE, 'async operation completed');
    return result;
  } catch (error) {
    console.error('[AsyncError]', error);
    transitionState(ComponentState.ERROR, 'async operation failed');
    throw error;
  }
}

// ❌ WRONG: Async without state tracking
async function performAsyncOperation(data) {
  const result = await someAsyncCall(data);
  return result; // No state management, no error handling
}
```

### 9. State Machine Prevention Plan Compliance (MANDATORY)

**ALWAYS follow the State Machine Prevention Plan patterns.** Use the established base classes and validation framework:

```javascript
// ✅ CORRECT: Use State Machine Prevention Plan components
import { StateMachine, createStateConfig } from '../ui/state-machine-base.js';
import { GlobalListenerManager } from '../ui/state-machine-base.js';
import { StateMachineValidator } from '../ui/state-machine-validator.js';

class ComponentStateMachine extends StateMachine {
  constructor(dependencies) {
    const stateConfig = createStateConfig(ComponentState);
    
    // Configure states with explicit setup, cleanup, and validation
    stateConfig[ComponentState.IDLE] = {
      setup: (stateData, stateMachine) => {
        if (stateMachine.globalListeners) {
          stateMachine.enableProximityDetection();
          stateMachine.setupIdleListeners();
        }
      },
      cleanup: (stateData, stateMachine) => {
        if (stateMachine.globalListeners) {
          stateMachine.disableProximityDetection();
          stateMachine.clearAllListeners();
        }
      },
      validate: (stateData, stateMachine) => {
        return stateMachine.proximityDetectionActive === true;
      }
    };
    
    super(ComponentState.IDLE, stateConfig);
    
    // Initialize properties after super constructor
    this.dependencies = dependencies;
    this.globalListeners = new GlobalListenerManager();
    
    // Re-initialize initial state now that properties are set
    this.initializeState(ComponentState.IDLE);
  }
}

// Register for automatic validation
const validator = new StateMachineValidator(componentStateMachine);
validator.validateCurrentState();
```

## Implementation Checklist

Before writing any event handler or async code, verify:

- [ ] **State Machine Base Class**: Extends `StateMachine` base class with proper configuration
- [ ] **Constructor Pattern**: Properties initialized after `super()` call
- [ ] **State Configuration**: Each state has explicit `setup`, `cleanup`, and `validate` functions
- [ ] **Property Access**: State setup functions use `stateMachine` parameter, not `this`
- [ ] **Global Listener Manager**: Uses `GlobalListenerManager` for centralized event handling
- [ ] **State Validation**: Includes validation functions for runtime consistency checking
- [ ] **Error Recovery**: Event wrapper with try/catch and state reset
- [ ] **Debug Logging**: Comprehensive logging for all events and state changes
- [ ] **Testing**: Each state machine has comprehensive test coverage
- [ ] **Validation Framework**: Uses `StateMachineValidator` for runtime validation

## Code Templates

### State Machine Prevention Plan Template

```javascript
// Import State Machine Prevention Plan components
import { StateMachine, createStateConfig } from '../ui/state-machine-base.js';
import { GlobalListenerManager } from '../ui/state-machine-base.js';
import { StateMachineValidator } from '../ui/state-machine-validator.js';

// State definition
const ComponentState = {
  IDLE: 'idle',
  PROCESSING: 'processing',
  ERROR: 'error'
};

class ComponentStateMachine extends StateMachine {
  constructor(dependencies) {
    const stateConfig = createStateConfig(ComponentState);
    
    // Configure each state with explicit setup, cleanup, and validation
    stateConfig[ComponentState.IDLE] = {
      setup: (stateData, stateMachine) => {
        if (stateMachine.globalListeners) {
          stateMachine.clearAllListeners();
          stateMachine.resetState();
        }
      },
      cleanup: (stateData, stateMachine) => {
        if (stateMachine.globalListeners) {
          stateMachine.clearAllListeners();
        }
      },
      validate: (stateData, stateMachine) => {
        return stateMachine.isIdle === true;
      }
    };
    
    stateConfig[ComponentState.PROCESSING] = {
      setup: (stateData, stateMachine) => {
        if (stateMachine.globalListeners) {
          stateMachine.setupProcessingListeners();
        }
      },
      cleanup: (stateData, stateMachine) => {
        if (stateMachine.globalListeners) {
          stateMachine.clearAllListeners();
        }
      },
      validate: (stateData, stateMachine) => {
        return stateMachine.isProcessing === true;
      }
    };
    
    super(ComponentState.IDLE, stateConfig);
    
    // Initialize properties after super constructor
    this.dependencies = dependencies;
    this.globalListeners = new GlobalListenerManager();
    
    // Re-initialize initial state now that properties are set
    this.initializeState(ComponentState.IDLE);
  }
  
  // Implementation methods
  clearAllListeners() {
    this.globalListeners.clearAll();
  }
  
  resetState() {
    this.isIdle = true;
    this.isProcessing = false;
  }
  
  setupProcessingListeners() {
    this.globalListeners.setListeners({
      'mousemove': this.handleMove.bind(this),
      'mouseup': this.handleEnd.bind(this)
    });
  }
  
  // Event handlers
  handleMove(event) {
    // Handle move event
  }
  
  handleEnd(event) {
    this.transitionTo(ComponentState.IDLE, 'operation completed');
  }
}

// Usage with validation
const componentStateMachine = new ComponentStateMachine(dependencies);
const validator = new StateMachineValidator(componentStateMachine);

// Validate current state
validator.validateCurrentState();
```

## Enforcement

These rules are **MANDATORY** for all new async code and event handlers. Any code that violates these patterns must be refactored before being merged.

## Benefits

Following these patterns ensures:
- **🛡️ Bug Prevention**: Eliminates state machine initialization bugs through proper constructor patterns
- **🔍 Better Debugging**: Complete event/state trace in console with comprehensive logging
- **🧪 Improved Testing**: Comprehensive testing framework with 34+ tests for state machine behavior
- **📚 Better Documentation**: Clear patterns and examples for future state machines
- **🔄 Consistent Architecture**: All state machines follow the same patterns and base classes
- **⚡ Better Performance**: Centralized listener management prevents memory leaks
- **🔧 Runtime Validation**: Automated validation catches issues within 5 seconds
- **🎯 Self-Documenting**: Code structure matches behavior with explicit state configurations
- **🧹 Proper Cleanup**: Automatic cleanup in state transitions prevents resource leaks
- **🚨 Error Recovery**: Automatic state reset on errors with proper cleanup

## References

These rules are derived from successful refactoring of:
- `CONNECTOR_EVENTS_REFACTORING_PLAN.md`
- `STICKY_EVENTS_REFACTORING_PLAN.md`
- `KEYBOARD_HANDLERS_REFACTORING_PLAN.md`
- `STATE_MACHINE_PREVENTION_PLAN.md` - Comprehensive implementation with base classes, validation framework, and testing utilities
